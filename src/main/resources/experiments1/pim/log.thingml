import "logbinary.thingml" from stl

thing fragment ConsoleLogger2 includes Logger @monitor "not"/* @stdout_sync "true" */ {
	
	abstract function encrypt(payload : Byte[], size : UInt8)
	
	function do_log(payload : Byte[], size : UInt8) @monitor "not" do
		encrypt(payload, size)		
	end
	
}

thing NoEncryptConsoleLogger includes ConsoleLogger2 
@stdout_sync "true" {
	function encrypt(payload : Byte[], size : UInt8) do
		var offset : Integer = 3
		if (payload[0] == LogType:custom) offset = 2
		readonly var realSize : Integer = size - offset
		var realPayload : Byte[realSize]
		for(v : Byte, i : Integer in payload) if (i>offset-1) realPayload[i-offset] = v
		if (payload[0] == LogType:custom) print "@["
		else print "#["
		for(w : Byte in realPayload) do
			print w as UInt8, ","
		end					
		println "]"
	end
}

thing CEncrypt includes ConsoleLogger2
@docker_install_pkg "libmcrypt-dev"
@c_header "
#include <mcrypt.h>
"
@c_global `
int encrypt(
    void* buffer,
    int buffer_len, /* Because the plaintext could include null bytes*/
    char* IV, 
    char* key,
    int key_len 
){
  MCRYPT td = mcrypt_module_open("rijndael-128", NULL, "cbc", NULL);
  int blocksize = mcrypt_enc_get_block_size(td);
  if( buffer_len % blocksize != 0 ){return 1;}

  mcrypt_generic_init(td, key, key_len, IV);
  mcrypt_generic(td, buffer, buffer_len);
  mcrypt_generic_deinit (td);
  mcrypt_module_close(td);
  
  return 0;
}
`
{
	readonly property seed : String = "1234567890123456"
	
	function encrypt(payload : Byte[], size : UInt8) do
	  var offset : Integer = 3
	  if (payload[0] == LogType:custom) offset = 2
	  `
	  MCRYPT td = mcrypt_module_open("rijndael-128", NULL, "cbc", NULL);
  	  int blocksize = mcrypt_enc_get_block_size(td);
	  `
	  readonly var realSize : Integer = `blocksize` as Integer //size - offset
	  var realPayload : Byte[realSize]
	  for(v : Byte, i : Integer in payload) if (i>offset-1) realPayload[i-offset] = v	
		
	  if (payload[0] == LogType:custom) do
			print "@["
			for(w : Byte, i : Integer in payload) do
				if (i>offset-1) print w as UInt8, ","
			end					
			println "]"	  							  				
	  		`
  	    	char* IV = ` & seed & `;
        	char *key = ` & seed & `;
        	int keysize = 16; /* 128 bits */      
        	encrypt(` & realPayload & `, ` & realSize & `, IV, key, keysize); 
	    	`
	    	print "$["
			for(w : Byte in realPayload) do
				print w as UInt8, ","
			end					
			println "]"	
	  end
	end
}

thing JavaEncrypt includes ConsoleLogger2 
@stdout_sync "true"
@maven_dep 
"
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-crypto</artifactId>
    <version>1.0.0</version>
</dependency>
"
@java_import 
"
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Properties;
  
import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
  
import org.apache.commons.crypto.cipher.CryptoCipher;
import org.apache.commons.crypto.cipher.CryptoCipherFactory;
import org.apache.commons.crypto.cipher.CryptoCipherFactory.CipherProvider;
import org.apache.commons.crypto.utils.Utils;
"
{
	readonly property seed : String = "1234567890123456"
	
	function encrypt(payload : Byte[], size : UInt8) do
		var offset : Integer = 3
		if (payload[0] == LogType:custom) offset = 2
		readonly var realSize : Integer = size - offset
		var realPayload : Byte[realSize]
		for(v : Byte, i : Integer in payload) if (i>offset-1) realPayload[i-offset] = v	
		
		if (payload[0] == LogType:custom) do
			print "@["
			for(w : Byte in realPayload) do
				print w as UInt8, ","
			end					
			println "]"
									
		var encryptedPayload : Byte[]
		`try {
		/** See http://commons.apache.org/proper/commons-crypto/xref-test/org/apache/commons/crypto/examples/CipherByteArrayExample.html **/
		final SecretKeySpec key = new SecretKeySpec(` & seed & `.getBytes(StandardCharsets.UTF_8),"AES");
		final IvParameterSpec iv = new IvParameterSpec(` & seed & `.getBytes(StandardCharsets.UTF_8));
		
		Properties properties = new Properties();
        //properties.setProperty(CryptoCipherFactory.CLASSES_KEY, CipherProvider.OPENSSL.getClassName());
        //Creates a CryptoCipher instance with the transformation and properties.
        final String transform = "AES/CBC/PKCS5Padding";
        CryptoCipher encipher = Utils.getCipherInstance(transform, properties);
        //System.out.println("Cipher:  " + encipher.getClass().getCanonicalName());
        
        byte[] input = ` & realPayload & `;
        byte[] output = new byte[32];
        
        //Initializes the cipher with ENCRYPT_MODE, key and iv.
        encipher.init(Cipher.ENCRYPT_MODE, key, iv);
        //Continues a multiple-part encryption/decryption operation for byte array.
        int updateBytes = encipher.update(input, 0, input.length, output, 0);
        //System.out.println(updateBytes);
        //We must call doFinal at the end of encryption/decryption.
        int finalBytes = encipher.doFinal(input, 0, 0, output, updateBytes);
        //System.out.println(finalBytes);
        //Closes the cipher.
        encipher.close();
        
        ` & encryptedPayload & ` = Arrays.copyOf(output, updateBytes+finalBytes);`
		print ">["
		for(w : Byte in encryptedPayload) do
			print w as UInt8, ","
		end					
		println "]"
		
		var decryptedPayload : Byte[realSize]
		`
		//properties.setProperty(CryptoCipherFactory.CLASSES_KEY, CipherProvider.JCE.getClassName());
        CryptoCipher decipher = Utils.getCipherInstance(transform, properties);
        //System.out.println("Cipher:  " + encipher.getClass().getCanonicalName());
   
        decipher.init(Cipher.DECRYPT_MODE, key, iv);
        byte [] decoded = new byte[32];
        decipher.doFinal(output, 0, updateBytes + finalBytes, decoded, 0);
        ` & decryptedPayload & ` = Arrays.copyOf(decoded, ` & realSize & `);`       
        print "<["
		for(w : Byte in decryptedPayload) do
			print w as UInt8, ","
		end					
		println "]"
        
		`} catch(Exception e) {e.printStackTrace();}`
		end
	end
}
