/**
 * Finite state machine library
 * Copyright (c) 2014-6 David Mesquita-Morris
 * Licensed under the MIT and GPL v3 licences
 * http://state.software
 */

/**
 * An enumeration used to dictate the behavior of instances of the [[PseudoState]] class.
 *
 * Use these constants as the `kind` parameter when creating new [[PseudoState]] instances to define their behavior (see the description of each member).
 */
export enum PseudoStateKind {
	/**
	 * Enables a dynamic conditional branches; within a compound [[Transition]].
	 *
	 * All outbound transition guards from a [[Choice]] [[PseudoState]] are evaluated upon entering the [[PseudoState]]: if a single [[Transition]] is found, it will be traversed; if many are found, an arbitary one will be selected and traversed; if none evaluate true, and there is no 'else transition' defined, the machine is deemed illformed and an exception will be thrown.
	 */
	Choice,

	/** As per [[ShallowHistory]], but the history semantic cascades through all child regions irrespective of their history semantics. */
	DeepHistory,

	/** Defines the [[PseudoState]] that will be the initial staring point when entering its enclosing [[Region]]. */
	Initial,

	/**
	 * Enables a static conditional branches; within a compound [[Transition]].
	 * 
	 * All outbound transition guards from a [[Junction]] [[PseudoState]] are evaluated upon entering the [[PseudoState]]: if a single [[Transition]] is found, it will be traversed; if many or none evaluate true, and there is no 'else transition' defined, the machine is deemed illformed and an exception will be thrown.
	 */
	Junction,

	/** Ensures that re-entry of the enclosing [[Region]] will start at the last known active state configuration. */
	ShallowHistory,

	/**
	 * Entering a terminate [[PseudoState]] implies that the execution of [[StateMachine]] is terminated and will not respond to any more messages.
	 * @depricated since v5.10.2 (use a transition to a top-leval state with no outbound transitions).
	 */
	Terminate
}

/**
 * An enumeration of that dictates the precise behavior of a [[Transition]] instance.
 *
 * Use these constants as the `kind` parameter when creating new [[Transition]] instances to define their behavior (see the description of each member).
 * @note Within the [[Transition]] constructor the `kind` parameter will be validated and adjusted as necessary.
 */
export enum TransitionKind {
	/** The [[Transition]], if triggered, will exit the source [[Vertex]] and enter the target [[Vertex]] irrespective of the proximity of source and target in terms of their enclosing [[Region]]. */
	External,

	/** The [[Transition]], if triggered, occurs without exiting or entering the source [[State]]; it does not cause a state therefore no [[State]] exit or entry [[Action]]s will be invoked, only [[Transition]] [[Action]]s. */
	Internal,

	/** The [[Transition]], if triggered, will not exit the source [[State]] as the target [[Vertex]] is a child of the source [[State]]. No exit [[Action]]s are invoked from the source [[State]], but [[Transition]] and entry [[Action]]s will be invoked as required. */
	Local
}

/**
 * An element within a model.
 * @param TParent The type of the [[Element]]s parent.
 */
export abstract class Element<TParent> {
	/**
	 * Creates a new instance of the [[Element]] class.
	 * @param parent The parent of this [[Element]]
	 */
	protected constructor(public readonly parent: TParent) {
	}
}

/**
 * An element within a model that has a name.
 * @param TParent The type of the [[NamedElement]]s parent.
 */
export abstract class NamedElement<TParent> extends Element<TParent> {
	/** The symbol used to separate [[NamedElement]] names within a fully qualified name. Change this static member to create different styles of qualified name generated by the [[toString]] method. */
	public static namespaceSeparator = ".";

	/** The [[NamedElement]] [[name]] as a namespace delimited by [[namespaceSeparator]]. */
	/** @internal */ readonly qualifiedName: string;

	/**
	 * Creates a new instance of the [[NamedElement]] class.
	 * @param name The name of the [[NamedElement]].
	 * @param parent The parent of this [[NamedElement]]
	 */
	protected constructor(public readonly name: string, parent: TParent) {
		super(parent);

		this.qualifiedName = parent ? parent.toString() + NamedElement.namespaceSeparator + name : name;
	}

	/** Returns the [[NamedElement]] [[name]] as a namespace delimited by [[namespaceSeparator]]. */
	public toString(): string {
		return this.qualifiedName;
	}
}

/**
 * An [[NamedElement]] within a [[StateMachine]] model that is a container (parent) of [[Vertex]] instances; a [[Region]] will be the child of a composite [[State]].
 * @note A [[Region]] is implicitly inserted into a composite [[State]] if not explicitly defined.
 */
export class Region extends NamedElement<State> {
	/** The name given to [[Region]] instances implicitly created (when a [[State]] instance is passed to a [[Vertex]] constructor as it's parent. */
	public static defaultName = "default";

	/** The [[Vertex]] instances that are children of this [[Region]]. */
	public readonly vertices = new Array<Vertex>();

	/**
	 * Creates a new instance of the [[Region]] class.
	 * @param name The name of the [[Region]].
	 * @param state The parent [[State]] that this [[Region]] will be a child of.
	 */
	public constructor(name: string, state: State) {
		super(name, state);

		this.parent.regions.push(this);
		this.getRoot().clean = false;
	}

	/** Removes this [[Region]] instance from the [[StateMachine]] model. */
	public remove() {
		for (const vertex of this.vertices) {
			vertex.remove();
		}

		this.parent.regions.splice(this.parent.regions.indexOf(this), 1);
		this.getRoot().clean = false;
	}

	/** Returns the root [[StateMachine]] instance that this [[Region]] is a part of. */
	public getRoot(): StateMachine {
		return this.parent.getRoot();
	}

	/**
	 * Accepts an instance of a [[Visitor]] and calls the [[visitRegion]] method on it.
	 * @param TArg1 The type of the first optional parameter.
	 * @param visitor The [[Visitor]] instance.
	 * @param arg1 An optional argument to pass into the [[Visitor]].
	 */
	public accept<TArg1>(visitor: Visitor<TArg1>, arg1?: TArg1): void {
		return visitor.visitRegion(this, arg1);
	}
}

/** An abstract [[NamedElement]] within a [[StateMachine]] model that can be the source or target of a [[Transition]]. */
export abstract class Vertex extends NamedElement<Region | undefined> {
	/** The [[Transition]]s originating from this [[Vertex]]. */
	public readonly outgoing = new Array<Transition>();

	/** The [[Transition]]s targeting this [[Vertex]]. */
	public readonly incoming = new Array<Transition>();

	/**
	 * Creates a new instance of the [[Vertex]] class.
	 * @param name The name of the [[Vertex]].
	 * @param parent The parent [[State]] or [[Region]].
	 * @note Specifting a [[State]] as the parent with cause the constructor to make this [[Vertex]] as child of the [[State]]s [[defaultRegion]].
	 */
	protected constructor(name: string, parent?: State | Region) {
		super(name, parent instanceof State ? parent.getDefaultRegion() : parent);

		if (this.parent) {
			this.parent.vertices.push(this);
		}

		this.getRoot().clean = false;
	}

	/** Returns the root [[StateMachine]] instance that this [[Vertex]] is a part of. */
	public getRoot(): StateMachine {
		return (this.parent!).getRoot(); // parent is only undefined for instances of StateMachine
	}

	/** Returns the ancestry of the [[Vertex]], form the root [[StateMachine]] to this [[Vertex]]. */
	public ancestry(): Array<Vertex> {
		return (this.parent ? this.parent.parent.ancestry() : new Array<Vertex>()).concat(this);
	}

	/** Removes the [[Vertex]] from the [[StateMachine]] model. */
	public remove() {
		for (const transitions of [this.outgoing, this.incoming]) {
			for (const transition of transitions) {
				transition.remove();
			}
		}

		if (this.parent) {
			this.parent.vertices.splice(this.parent.vertices.indexOf(this), 1);
		}

		this.getRoot().clean = false;
	}

	/**
	 * Creates a new [[Transition]] originating from this [[Vertex]]. Newly created transitions are completion [[Transition]]s; they will be evaluated after a [[Vertex]] has been entered if it is deemed to be complete. The [[Transition]] can be converted to be event triggered by adding a guard condition via the [[Transition]]s where method.
	 * @param target The destination of the [[Transition]]; omit for internal [[Transition]]s.
	 * @param kind The kind the [[Transition]]; use this to set [[Local]] or [[External]] (the default if omitted) [[Transition]] semantics.
	 */
	public to(target?: Vertex, kind: TransitionKind = TransitionKind.External): Transition {
		return new Transition(this, target, kind);
	}

	/**
	 * Accepts an instance of a [[Visitor]].
	 * @param TArg1 The type of the first optional parameter.
	 * @param visitor The [[Visitor]] instance.
	 * @param arg1 An optional argument to pass into the [[Visitor]].
	 */
	public abstract accept<TArg1>(visitor: Visitor<TArg1>, arg1?: TArg1): void;
}

/**
 * An [[Vertex]] within a [[StateMachine]] model that represents an transitory [[Vertex]].
 *
 * [[PseudoState]]s are required in state machine models to define the default stating state of a [[Region]]. [[PseudoState]]s are also used for defining history semantics or to facilitate more complex transitions. A [[Terminate]] [[PseudoState]] kind is also available to immediately terminate processing within the entire state machine instance.
 */
export class PseudoState extends Vertex {
	/**
	 * Creates a new instance of the [[PseudoState]] class.
	 * @param name The name of the [[PseudoState]].
	 * @param parent The parent [[State]] or [[Region]] that this [[PseudoState]] will be a child of.
	 * @param kind The kind of the [[PseudoState]] which determines its use and behavior.
	 */
	public constructor(name: string, parent: State | Region, public readonly kind: PseudoStateKind = PseudoStateKind.Initial) {
		super(name, parent);
	}

	/**
	 * Tests a [[PseudoState]] to determine if it is a history [[PseudoState]].
	 * History [[PseudoState]]s are of kind: [[ShallowHistory]] or [[DeepHistory]].
	 * @returns True if the [[PseudoStateKind]] is [[DeepHistory]] or [[ShallowHistory]].
	 */
	public isHistory(): boolean {
		return this.kind === PseudoStateKind.DeepHistory || this.kind === PseudoStateKind.ShallowHistory;
	}

	/**
	 * Tests a [[PseudoState]] to determine if it is an initial [[PseudoState]].
	 * Initial [[PseudoState]]s are of kind: [[Initial]], [[ShallowHistory]], or [[DeepHistory]].
	 * @returns True if the [[PseudoStateKind]] is [[Initial]], [[DeepHistory]] or [[ShallowHistory]].
	 */
	public isInitial(): boolean {
		return this.kind === PseudoStateKind.Initial || this.isHistory();
	}

	/**
	 * Accepts an instance of a [[Visitor]] and calls the [[visitPseudoState]] method on it.
	 * @param visitor The [[Visitor]] instance.
	 * @param arg1 An optional argument to pass into the [[Visitor]].
	 */
	public accept<TArg1>(visitor: Visitor<TArg1>, arg1?: TArg1): void {
		return visitor.visitPseudoState(this, arg1);
	}
}

/**
 * A [[Vertex]] within a [[StateMachine]] model that represents an invariant condition within the life of the state machine instance.
 *
 * [[State]] instances are one of the fundamental building blocks of the [[StateMachine]] model; they typically represent conditions where the machine is awaiting an eveny to trigger a [[Transition]]. User-defined [[Action]]s can be defined for both [[State]] entry and [[State]] exit.
 */
export class State extends Vertex {
	/** The user-defined behavior (built up via calls to the [[exit]] method). */
	/** @internal */ readonly exitBehavior = new Array<Action>();

	/** The user-defined behavior (built up via calls to the [[entry]] method). */
	/** @internal */ readonly entryBehavior = new Array<Action>();

	/** The default [[Region]] if present; created when vertices are created directly under this [[State]]. */
	/** @internal */ defaultRegion: Region;

	/** The [[Region]] instances that are a child of  this [[State]]. */
	public readonly regions = new Array<Region>();

	/**
	 * Creates a new instance of the [[State]] class.
	 * @param name The name of the [[State]].
	 * @param parent The parent [[State]] or [[Region]] that this [[State is a child of]].
	 * @note When the parent parameter is of type [[State]], a default [[Region]] is created and subsiquently accessible via the [[defaultRegion]] method.
	 */
	public constructor(name: string, parent?: State | Region) {
		super(name, parent);
	}

	/**
	 * Returns the default [[Region]] for the state.
	 * @note A default [[Region]] is created on demand if the [[State]] is passed into a child [[Vertex]] constructor..
	 */
	public getDefaultRegion(): Region {
		return this.defaultRegion || (this.defaultRegion = new Region(Region.defaultName, this));
	}

	/** Tests the [[State]] to see if it is a [[FinalState]]; a [[FinalState]] is either defined by creating an instance of the [[FinalState]] class or any other [[State]] instance that has no outbound transitions. */
	public isFinal(): boolean {
		return this.outgoing.length === 0;
	}

	/** Tests the [[State]] to see if it is a simple [[State]]; a simple [[State]] is one that has no child [[Region]]s. */
	public isSimple(): boolean {
		return this.regions.length === 0;
	}

	/** Tests the [[State]] to see if it is a composite [[State]]; a composite [[State]] is one that has one or more child [[Region]]s. */
	public isComposite(): boolean {
		return this.regions.length > 0;
	}

	/** Tests the [[State]] to see if it is an orthogonal [[State]]; an orthogonal [[State]] is one that has more than one child [[Region]]s. */
	public isOrthogonal(): boolean {
		return this.regions.length > 1;
	}

	/** Removes this [[State]] instance from the [[StateMachine]] model. */
	public remove() {
		for (const region of this.regions) {
			region.remove();
		}

		super.remove();
	}

	/**
	 * Adds an [[Action]] that is executed each time the [[State]] instance is exited due to a [[Transition]].
	 * @param exitAction The [[Action]] to add to the [[State]] instance exit behavior.
	 */
	public exit(exitAction: Action) {
		this.exitBehavior.push(exitAction);
		this.getRoot().clean = false;

		return this;
	}

	/**
	 * Adds and [[Action]] that is executed each time the [[State]] instance is entered due to a [[Transition]].
	 * @param entryAction The [[Action]] to add to the [[State]] instance entry behavior.
	 */
	public entry(entryAction: Action) {
		this.entryBehavior.push(entryAction);
		this.getRoot().clean = false;

		return this;
	}

	/**
	 * Accepts an instance of a [[Visitor]] and calls the [[visitState]] method on it.
	 * @param TArg1 The type of the first optional parameter.
	 * @param visitor The [[Visitor]] instance.
	 * @param arg1 An optional argument to pass into the [[Visitor]].
	 */
	public accept<TArg1>(visitor: Visitor<TArg1>, arg1?: TArg1): void {
		return visitor.visitState(this, arg1);
	}
}

/**
 * A [[State]] within a [[StateMachine]] model that represents completion of the life of the containing [[Region]] for the state machine instance.
 * @note A [[FinalState]] cannot have outbound transitions.
 * @depricated since v5.10.1 (use [[State]] class instead).
 */
export class FinalState extends State {
	/**
	 * Creates a new instance of the [[FinalState]] class.
	 * @param name The name of the [[FinalState]].
	 * @param parent The parent [[State]] or [[Region]] that owns the [[FinalState]].
	 */
	public constructor(name: string, parent: State | Region) {
		super(name, parent);
	}

	/**
	 * Accepts an instance of a [[Visitor]] and calls the [[visitFinalState]] method on it.
	 * @param TArg1 The type of the first optional parameter.
	 * @param visitor The [[Visitor]] instance.
	 * @param arg1 An optional argument to pass into the [[Visitor]].
	 */
	public accept<TArg1>(visitor: Visitor<TArg1>, arg1?: TArg1): void {
		return visitor.visitFinalState(this, arg1);
	}
}

/** The root of a [[StateMachine]] model. */
export class StateMachine extends State {
	/** Internal flag: false if the state machine model requires recompilation. */
	/** @internal */ clean = false;

	/** The behavior to be executed when initialising a state machine instance. */
	/** @internal */ onInitialise: Array<Action>;

	/**
	 * Creates a new instance of the [[StateMachine]] class.
	 * @param name The name of the [[StateMachine]].
	 */
	public constructor(name: string) {
		super(name, undefined);
	}

	/**
	 * Returns the root [[StateMachine]].
	 * @note that if this [[StateMachine]] is embeded within another, the ultimate root will be returned.
	 */
	public getRoot(): StateMachine {
		return this.parent ? this.parent.getRoot() : this;
	}

	/**
	 * Accepts an instance of a [[Visitor]] and calls the [[visitStateMachine]] method on it.
	 * @param TArg1 The type of the first optional parameter.
	 * @param visitor The [[Visitor]] instance.
	 * @param arg1 An optional argument to pass into the [[Visitor]].
	 */
	public accept<TArg1>(visitor: Visitor<TArg1>, arg1?: TArg1): void {
		return visitor.visitStateMachine(this, arg1);
	}
}

/** A function that always returns true. */
/** @internal */ const TrueFunc = () => { return true; };

/** A function that always returns false. */
/** @internal */ const FalseFunc = () => { return false; };

/**
 * Represents a [[State]] change that may occur in response to a message; essentially, the [[Transition]] represents a path between two [[Vertex]] instances.
 *
 * Transitions come in a variety of types and are described by the [[TransitionKind]] enumeration.
 */
export class Transition {
	/** The guard condition associated with this [[Transition]]. */
	/** @internal */ guard: (message?: any, instance?: IInstance) => boolean;

	/** The user-defined [[Action]]s that will be invoked when this [[Transition]] is traversed. */
	/** @internal */ readonly transitionBehavior = new Array<Action>();

	/**
	 * The full set of [[Action]]s that will be invoked when this [[Transition]] is traversed.
	 * @note This includes the exit [[Action]]s of the [[source]] [[Vertex]] and entry [[Action]]s of the [[target]] [[Vertex]].
	 */
	/** @internal */ onTraverse: Array<Action>;

	/**
	 * Creates a new instance of the [[Transition]] class.
	 * @param source The source [[Vertex]] of the [[Transition]].
	 * @param source The target [[Vertex]] of the [[Transition]]; this is an optional parameter, omitting it will create an [[Internal]] [[Transition]].
	 * @param kind The kind the [[Transition]]; use this to set [[Local]] or [[External]] (the default if omitted) transition semantics.
	 */
	public constructor(public readonly source: Vertex, public readonly target?: Vertex, public readonly kind: TransitionKind = TransitionKind.External) {
		if (!this.target) {
			this.kind = TransitionKind.Internal;
		}

		this.guard = source instanceof PseudoState ? TrueFunc : (message => message === this.source);

		this.source.outgoing.push(this);

		if (this.target) {
			this.target.incoming.push(this);
		}

		this.source.getRoot().clean = false;
	}

	/**
	 * Turns a [[Transition]] into an else transition.
	 * Else [[Transitions]]s can be used at [[Junction]] or [[Choice]] [[PseudoState]] if no other [[Transition]] guards evaluate true, an else [[Transition]] if present will be traversed.
	 */
	public else() {
		this.guard = FalseFunc;

		return this;
	}

	/**
	 * Defines the guard condition for the [[Transition]].
	 * @param guard The guard condition that must evaluate true for the [[Transition]] to be traversed.
	 * @note While this supports the fluent API style, multiple calls to the [[when]] method will will just result in the guard condition specified in last [[when]] call made.
	 */
	public when(guard: (message?: any, instance?: IInstance) => boolean) {
		this.guard = guard;

		return this;
	}

	/**
	 * Adds and [[Action]] to a [[Transition]].
	 * @param transitionAction The [[Action]] to add to the [[Transition]] behavior.
	 * @note Make multiple calls to this method to add mutiple actions to the [[Transition]] behavior.
	 */
	public effect(transitionAction: Action) {
		this.transitionBehavior.push(transitionAction);
		this.source.getRoot().clean = false;

		return this;
	}

	/** Removes the [[Transition]] from the [[StateMachine]] model. */
	public remove() {
		this.source.outgoing.splice(this.source.outgoing.indexOf(this), 1);

		if (this.target) {
			this.target.incoming.splice(this.target.incoming.indexOf(this), 1);
		}

		this.source.getRoot().clean = false;
	}

	/**
	 * Accepts an instance of a [[Visitor]] and calls the [[visitTransition]] method on it.
	 * @param TArg1 The type of the first optional parameter.
	 * @param visitor The [[Visitor]] instance.
	 * @param arg1 An optional argument to pass into the [[Visitor]].
	 */
	public accept<TArg1>(visitor: Visitor<TArg1>, arg1?: TArg1): void {
		return visitor.visitTransition(this, arg1);
	}

	/** Returns a the [[Transition]] name. */
	public toString(): string {
		return `[${this.target ? (this.source + " -> " + this.target) : this.source}]`;
	}
}

/**
 * A working implementation of the [[IInstance]] interface.
 * @note It is possible to create other custom state machine instance classes in other ways (e.g. serialisable JSON); just implement the [[IInstance]] interface.
 */
export class StateMachineInstance implements IInstance {
	/** The last known [[Vertex]] of any [[Region]] within the state machine instance. */
	/** @internal */ readonly current: { [id: string]: Vertex } = {};

	/** The last known [[State]] of any [[Region]] within the state machine instance. */
	/** @internal */ readonly last: { [id: string]: State } = {};

	/** Indicates that the [[StateMachine]] instance reached was terminated by reaching a [[Terminate]] [[PseudoState]]. */
	public isTerminated: boolean = false;

	/**
	 * Creates a new instance of the [[StateMachineInstance]] class.
	 * @param name The optional name of the [[StateMachineInstance]].
	 */
	public constructor(public name: string = "unnamed") {
		this.name = name;
	}

	/**
	 * Updates the last known [[State]] for a given [[Region]].
	 * @param region The [[Region]] to set the last known [[State]] of.
	 * @param vertex The last known [[Vertex]] of the given [[Region]]. 
	 */
	setCurrent(region: Region, vertex: Vertex): void {
		this.current[region.toString()] = vertex;

		if (vertex instanceof State) {
			this.last[region.toString()] = vertex;
		}
	}

	/**
	 * Returns the last known [[Vertex]] for a given [[Region]].
	 * @param region The [[Region]] to get the last known [[Vertex]] of.
	 * @returns The last known [[Vertex]] of the given [[Region]]. 
	 */
	getCurrent(region: Region): Vertex | undefined {
		return this.current[region.toString()];
	}

	/**
	 * Returns the last known [[State]] for a given [[Region]].
	 * @param region The [[Region]] to get the last known [[State]] of.
	 * @returns The last known [[State]] of the given [[Region]]. 
	 */
	getLastKnownState(region: Region): State | undefined {
		return this.last[region.toString()];
	}

	/**
	 * Returns the name of the [[StateMachineInstance]].
	 * @returns The name of this [[StateMachineInstance]].
	 */
	public toString(): string {
		return this.name;
	}
}

/** Definition of a node within a JSON representation of the active state configuration of a state machine model. */
interface IJSONNode {
	/** The name of the named element. */
	name: string;

	/** Child nodes. */
	children: IJSONNode[];

	/** The last known state for nodes representing regions. */
	lastKnown?: string;
}

/** Manages the active state configuration of a state machine instance using a serializable JSON structure. */
export class JSONInstance implements IInstance {
	/** The last known [[Vertex]] of any [[Region]] within the state machine instance. */
	/** @internal */ readonly current: { [id: string]: Vertex } = {};

	/** The active state configuration represented as a JSON object */
	private activeStateConfiguration: IJSONNode;

	/** Indicates that the state machine instance has reached a [[PseudoStateKind.Terminate]] [[PseudoState]] and therfore will no longer respond to messages. */
	public isTerminated: boolean = false;

	/**
	 * Creates a new instance of the [[JSONInstance]] class.
	 * @param name The optional name of the [[JSONInstance]].
	 */
	public constructor(public name: string = "unnamed") { }

	/**
	 * Updates the last known [[State]] for a given [[Region]].
	 * @param region The [[Region]] to set the last known [[State]] of.
	 * @param vertex The last known [[Vertex]] of the given [[Region]]. 
	 */
	public setCurrent(region: Region, vertex: Vertex): void {
		this.current[region.toString()] = vertex;

		if (vertex instanceof State) {
			this.getNode(region).lastKnown = vertex.name;
		}
	}

	/**
	 * Returns the last known [[Vertex]] for a given [[Region]].
	 * @param region The [[Region]] to get the last known [[Vertex]] of.
	 * @returns The last known [[Vertex]] of the given [[Region]]. 
	 */
	getCurrent(region: Region): Vertex | undefined {
		return this.current[region.toString()];
	}

	/**
	 * Returns the last known [[State]] for a given [[Region]].
	 * @param region The [[Region]] to get the last known [[State]] of.
	 * @returns The last known [[State]] of the given [[Region]]. 
	 */
	public getLastKnownState(region: Region): State | undefined {
		const lastKnown = this.getNode(region).lastKnown;

		return region.vertices.reduce<State | undefined>((result, item) => item instanceof State && item.name === lastKnown ? item : result, undefined);
	}

	/** Finds a node within the active state configuration for a given Region. */
	private getNode(stateOrRegion: State | Region): IJSONNode {
		if (stateOrRegion.parent) {
			const parentNode = this.getNode(stateOrRegion.parent);
			let node = parentNode.children.reduce((result, item) => item.name === stateOrRegion.name ? item : result, undefined);

			if (!node) {
				node = { "name": stateOrRegion.name, "children": [] };

				parentNode.children.push(node);
			}

			return node;
		} else {
			return this.activeStateConfiguration || (this.activeStateConfiguration = { "name": stateOrRegion.name, "children": [] });
		}
	}

	/**
	 * Returns the active state configuration as a JSON string.
	 * @returns A JSON string representation of the active state configuration.
	 */
	public toJSON(): string {
		return JSON.stringify(this.activeStateConfiguration);
	}

	/**
	 * Sets the active state configuration from a JSON string.
	 * @param json A JSON string representation of the active state configuration.
	 */
	public fromJSON(json: string) {
		return this.activeStateConfiguration = JSON.parse(json);
	}

	/**
	 * Returns the name of the [[StateMachineInstance]].
	 * @returns The name of this [[StateMachineInstance]].
	 */
	public toString(): string {
		return this.name;
	}
}

/**
 * Implementation of a visitor pattern.
 * @param TArg1 The type of the first optional parameter in the visit methods.
 */
export abstract class Visitor<TArg1> {
	/**
	 * Visits a [[NamedElement]] within a [[StateMachine]] model.
	 * @param region The [[Vertex]] or [[Region]] being visited.
	 * @param arg1 An optional parameter passed into the accept method.
	 */
	public visitNamedElement(namedElement: Vertex | Region, arg1?: TArg1): void {
	}

	/**
	 * Visits a [[Region]] within a [[StateMachine]] model.
	 * @param region The [[Region]] being visited.
	 * @param arg1 An optional parameter passed into the accept method.
	 */
	public visitRegion(region: Region, arg1?: TArg1): void {
		this.visitNamedElement(region, arg1);

		for (const vertex of region.vertices) {
			vertex.accept(this, arg1);
		}
	}

	/**
	 * Visits a [[Vertex]] within a [[StateMachine]] model.
	 * @param vertex The [[Vertex]] being visited.
	 * @param arg1 An optional parameter passed into the accept method.
	 */
	public visitVertex(vertex: Vertex, arg1?: TArg1): void {
		this.visitNamedElement(vertex, arg1);

		for (const transition of vertex.outgoing) {
			transition.accept(this, arg1);
		}
	}

	/**
	 * Visits a [[PseudoState]] within a [[StateMachine]] model.
	 * @param pseudoState The [[PseudoState]] being visited.
	 * @param arg1 An optional parameter passed into the accept method.
	 */
	public visitPseudoState(pseudoState: PseudoState, arg1?: TArg1): void {
		return this.visitVertex(pseudoState, arg1);
	}

	/**
	 * Visits a [[State]] within a [[StateMachine]] model.
	 * @param state The [[State]] being visited.
	 * @param arg1 An optional parameter passed into the accept method.
	 */
	public visitState(state: State, arg1?: TArg1): void {
		const result = this.visitVertex(state, arg1);

		for (const region of state.regions) {
			region.accept(this, arg1);
		}

		return result;
	}

	/**
	 * Visits a [[FinalState]] within a [[StateMachine]] model.
	 * @param finalState The [[FinalState]] being visited.
	 * @param arg1 An optional parameter passed into the accept method.
	 */
	public visitFinalState(finalState: FinalState, arg1?: TArg1): void {
		return this.visitState(finalState, arg1);
	}

	/**
	 * Visits a [[StateMachine]] within a [[StateMachine]] model.
	 * @param state machine The [[StateMachine]] being visited.
	 * @param arg1 An optional parameter passed into the accept method.
	 */
	public visitStateMachine(model: StateMachine, arg1?: TArg1): void {
		return this.visitState(model, arg1);
	}

	/**
	 * Visits a [[Transition]] within a [[StateMachine]] model.
	 * @param transition The [[Transition]] being visited.
	 * @param arg1 An optional parameter passed into the accept method.
	 */
	public visitTransition(transition: Transition, arg1?: TArg1): void {
	}
}

/**
 * Function prototype for the state transition behavior and [[State]] entry and exit behavior.
 * @param message The message that caused the [[Transition]].
 * @param instance The state machine instance.
 * @param deepHistory True if [[PseudoStateKind.DeepHistory]] semantics are in play.
 */
export interface Action {
	(message: any, instance: IInstance, deepHistory: boolean): void;
}

/**
 * The interface used to describe a state machine instance.
 * 
 * State machine instances hold the active state configuration for an instance of a [[StateMachine]] model. The state library allows there to be multiple state machine instances for a [[StateMachine]] model. By creating implementations of this interface, you can control how the active state configuration is managed, e.g. if persistence is required.
 */
export interface IInstance {
	/** Indicates that the state machine instance has reached a [[PseudoStateKind.Terminate]] [[PseudoState]] and therfore will no longer respond to messages. */
	isTerminated: boolean;

	/**
	 * Updates the last known [[State]] for a given [[Region]].
	 * @param region The [[Region]] to update the last known [[State]] for.
	 * @param vertex The last known [[Vertex]] for the given [[Region]].
	 */
	setCurrent(region: Region, vertex: Vertex): void;

	/**
	 * Returns the last known [[Vertex]] for a given [[Region]].
	 * @param region The [[Region]] to get the last known [[Vertex]] for.
	 */
	getCurrent(region?: Region): Vertex | undefined;

	/**
	 * Returns the last known [[State]] for a given [[Region]].
	 * @param region The [[Region]] to get the last known [[State]] for.
	 */
	getLastKnownState(region?: Region): State | undefined;
}

/**
 * Determines if a [[Vertex]] is currently active for a given state machine instance; i.e. that it has been entered but not yet exited.
 * @param vertex The [[Vertex]] to test.
 * @param instance The state machine instance.
 */
/** @internal */ function isActive(vertex: Vertex, instance: IInstance): boolean {
	return vertex.parent ? isActive(vertex.parent.parent, instance) && instance.getLastKnownState(vertex.parent) === vertex : true;
}

/**
 * Tests a [[State]] or [[Region]] within a state machine instance to see if its lifecycle is complete.
 * 
 * A [[State]] is deemed complete when it has reached a [[FinalState]] or a [[State]] that has no outgoing [[Transition]]s; a [[Region]] is deemed complete if all its child [[Region]]s are complete.
 * @param stateOrRegion The [[State]] or [[Region]] to test.
 * @param instance The state machine instance.
 */
export function isComplete(stateOrRegion: State | Region, instance: IInstance): boolean {
	if (stateOrRegion instanceof Region) {
		const currentState = instance.getLastKnownState(stateOrRegion);

		return currentState !== undefined && currentState.isFinal();
	} else {
		return stateOrRegion.regions.every(region => isComplete(region, instance));
	}
}

/** Concatenates arrays of [[Action]]s. */
/** @internal */ function push(to: Array<Action>, ...actions: Array<Array<Action>>): void {
	for (const set of actions) {
		for (const action of set) {
			to.push(action);
		}
	}
}

/**
 * Invokes behavior.
 * @param actions The set of [[Action]]s to invoke.
 * @param message The message that caused the [[Transition]] to be traversed that is triggering this behavior.
 * @param instance The state machine instance.
 * @param deepHistory True if [[DeepHistory]] semantics are in force at the time the behavior is invoked.
 */
/** @internal */ function invoke(actions: Array<Action>, message: any, instance: IInstance, deepHistory: boolean = false) {
	for (const action of actions) {
		action(message, instance, deepHistory);
	}
}

/** The function used for to generate random numbers; may be overriden for testing or other specific purposes. */
export let random: (max: number) => number = (max: number) => Math.floor(Math.random() * max);

/**
 * Updates the method used to generate random numbers.
 * @param value The new method that will be used to generate random numbers.
 */
export function setRandom(value: (max: number) => number): void {
	random = value;
}

/**
 * Initialises a state machine instance and/or [[StateMachine]] model.
 *
 * Passing just the [[StateMachine]] model will initialise the model, passing the [[StateMachine]] model and instance will initialse the instance and if necessary, the model.
 * @param model The [[StateMachine]] model. If autoInitialiseModel is true (or no instance is specified) and the model has changed, the model will be initialised.
 * @param instance The optional state machine instance to initialise.
 * @param autoInitialiseModel Defaulting to true, this will cause the model to be initialised prior to initialising the instance if the model has changed.
 */
export function initialise(model: StateMachine, instance?: IInstance, autoInitialiseModel: boolean = true): void {
	if (instance) {
		// initialise the state machine model if necessary
		if (autoInitialiseModel && model.clean === false) {
			initialise(model);
		}

		console.log(`initialise ${instance}`);

		// enter the state machine instance for the first time
		invoke(model.onInitialise, undefined, instance);
	} else {
		console.log(`initialise ${model.name}`);

		// initialise the state machine model
		model.accept(new InitialiseElements(), false);
		model.clean = true;
	}
}

/**
 * Passes a message to a state machine instance for evaluation; a message may trigger a [[Transition]].
 * @param model The [[StateMachine]] model.
 * @param instance The state machine instance.
 * @param message The message to evaluate.
 * @param autoInitialiseModel Defaulting to true, this will cause the [[StateMachine]] model to be initialised prior to initialising the instance if the model has changed.
 * @returns Returns true if the message caused a [[Transition]].
 */
export function evaluate(model: StateMachine, instance: IInstance, message: any, autoInitialiseModel: boolean = true): boolean {
	// initialise the state machine model if necessary
	if (autoInitialiseModel && model.clean === false) {
		initialise(model);
	}

	console.log(`${instance} evaluate ${message}`);

	// terminated state machine instances will not evaluate messages
	if (instance.isTerminated) {
		return false;
	}

	return evaluateState(model, instance, message);
}

/**
 * Evaluates messages against a [[State]], executing a [[Transition]].
 * @param state The [[State]].
 * @param instance The state machine instance.
 * @param message The message to evaluate.
 * @returns Returns true if the message caused a [[Transition]].
 */
/** @internal */ function evaluateState(state: State, instance: IInstance, message: any): boolean {
	let result = false;

	// delegate to child regions first if a non-continuation
	if (message !== state) {
		state.regions.every(region => {
			const currentState = instance.getLastKnownState(region);

			if (currentState && evaluateState(currentState, instance, message)) {
				result = true;

				return isActive(state, instance); // NOTE: this just controls the every loop; also isActive is a litte costly so using sparingly
			}

			return true; // NOTE: this just controls the every loop
		});
	}

	// if a transition occured in a child region, check for completions
	if (result) {
		if ((message !== state) && isComplete(state, instance)) {
			evaluateState(state, instance, state);
		}
	} else {
		// otherwise look for a transition from this state
		const transitions = state.outgoing.filter(transition => transition.guard(message, instance));

		if (transitions.length === 1) {
			// execute if a single transition was found
			result = traverse(transitions[0], instance, message);
		} else if (transitions.length > 1) {
			// error if multiple transitions evaluated true
			console.error(`${state}: multiple outbound transitions evaluated true for message ${message}`);
		}
	}

	return result;
}

/**
 * Traverses a [[Transition]].
 * 
 * This method encapsulates the logic for dynamic and static conditional [[Transition]] branches ([[Choice]] and [[Junction]] respectively).
 * @param transition The [[Transition]] to traverse.
 * @param instance The state machine instance.
 * @param message The message that triggerd this [[Transition]] traversal.
 * @returns Always returns true.
 */
/** @internal */ function traverse(transition: Transition, instance: IInstance, message?: any): boolean {
	let onTraverse = transition.onTraverse.slice(0);

	// process static conditional branches - build up all the transition behavior prior to executing
	while (transition.target && transition.target instanceof PseudoState && transition.target.kind === PseudoStateKind.Junction) {
		// proceed to the next transition
		transition = selectTransition(transition.target, instance, message);

		// concatenate behavior before and after junctions
		push(onTraverse, transition.onTraverse);
	}

	// execute the transition behavior
	invoke(onTraverse, message, instance);

	if (transition.target) {
		// process dynamic conditional branches if required
		if (transition.target instanceof PseudoState && transition.target.kind === PseudoStateKind.Choice) {
			traverse(selectTransition(transition.target, instance, message), instance, message);
		}

		// test for completion transitions
		else if (transition.target instanceof State && isComplete(transition.target, instance)) {
			evaluateState(transition.target, instance, transition.target);
		}
	}

	return true;
}

/**
 * Select next leg of a composite [[Transition]] after a [[Choice]] or [[Junction]] [[PseudoState]].
 * @param pseudoState The [[Choice]] or [[Junction]] [[PseudoState]].
 * @param instance The state machine instance.
 * @param message The message that triggerd the transition to the [[PseudoState]].
 */
/** @internal */ function selectTransition(pseudoState: PseudoState, instance: IInstance, message: any): Transition {
	const transitions = pseudoState.outgoing.filter(transition => transition.guard(message, instance));

	if (pseudoState.kind === PseudoStateKind.Choice) {
		return transitions.length !== 0 ? transitions[random(transitions.length)] : findElse(pseudoState);
	}

	if (transitions.length > 1) {
		console.error(`Multiple outbound transition guards returned true at ${pseudoState} for ${message}`);
	}

	return transitions[0] || findElse(pseudoState);
}

/** Look for an else [[Transition]] from a [[Junction]] or [[Choice]] [[PseudoState]]. */
/** @internal */ function findElse(pseudoState: PseudoState): Transition {
	return pseudoState.outgoing.filter(transition => transition.guard === FalseFunc)[0];
}

/** Class used to temporarily hold behavior during [[StateMachine]] initialisation. */
/** @internal */ class Behavior {
	/** The [[Action]]s to execute when leaving a [[Vertex]] or [[Region]] during a state transition (including and cascaded [[Action]]s). */
	readonly leave = new Array<Action>();

	/** The initial [[Action]]s to execute when entering a [[Vertex]] or [[Region]] during a state transition. */
	readonly beginEnter = new Array<Action>();

	/** The follow-on [[Action]]s to execute when entering a [[Vertex]] or [[Region]] during a state transition (including and cascaded [[Action]]s). */
	readonly endEnter = new Array<Action>();

	/** The full set of [[Action]]s to execute when entering a [[Vertex]] or [[Region]] during a state transition (including and cascaded [[Action]]s). */
	enter(): Array<Action> {
		const result = new Array<Action>();

		push(result, this.beginEnter, this.endEnter);

		return result;
	}
}

/** Initialises the transitions within a [[StateMachine]]. */
/** @internal */ class InitialiseTransitions extends Visitor<(vertexOrRegion: Vertex | Region) => Behavior> {
	visitTransition(transition: Transition, behavior: (vertexOrRegion: Vertex | Region) => Behavior) {
		// reset transition behavior
		transition.onTraverse = new Array<Action>();

		// initialise transition behavior based on transition kind
		switch (transition.kind) {
			case TransitionKind.Internal:
				this.visitInternalTransition(transition, behavior);
				break;

			case TransitionKind.Local:
				this.visitLocalTransition(transition, behavior);
				break;

			case TransitionKind.External:
				this.visitExternalTransition(transition, behavior);
				break;
		}
	}

	// initialise internal transitions: these do not leave the source state
	visitInternalTransition(transition: Transition, behavior: (vertexOrRegion: Vertex | Region) => Behavior) {
		// perform the transition behavior
		push(transition.onTraverse, transition.transitionBehavior);

		// add a test for completion
		if (internalTransitionsTriggerCompletion) {
			transition.onTraverse.push((message, instance) => {
				if (transition.source instanceof State && isComplete(transition.source, instance)) {
					evaluateState(transition.source, instance, transition.source);
				}
			});
		}
	}

	// initialise transitions within the same region
	visitLocalTransition(transition: Transition, behavior: (vertexOrRegion: Vertex | Region) => Behavior) {
		transition.onTraverse.push((message, instance) => {
			const targetAncestors = transition.target!.ancestry(); // local transitions will have a target
			let i = 0;

			// find the first inactive element in the target ancestry
			while (isActive(targetAncestors[i], instance)) { ++i; }

			// exit the active sibling // TODO: check logic
			const currentState = instance.getCurrent(targetAncestors[i].parent); // NOTE: possible fix

			if (currentState) {
				invoke(behavior(currentState).leave, message, instance);
			}

			// perform the transition action;
			invoke(transition.transitionBehavior, message, instance);

			// enter the target ancestry
			while (i < targetAncestors.length) {
				this.cascadeElementEntry(transition, behavior, targetAncestors[i++], targetAncestors[i], behavior => invoke(behavior, message, instance));
			}

			// trigger cascade
			invoke(behavior(transition.target!).endEnter, message, instance);
		});
	}

	// initialise external transitions: these are abritarily complex
	visitExternalTransition(transition: Transition, behavior: (vertexOrRegion: Vertex | Region) => Behavior) {
		const sourceAncestors = transition.source.ancestry(), targetAncestors = transition.target!.ancestry(); // external transtions always have a target
		let i = Math.min(sourceAncestors.length, targetAncestors.length) - 1;

		// find the index of the first uncommon ancestor (or for external transitions, the source)
		while (sourceAncestors[i - 1] !== targetAncestors[i - 1]) { --i; }

		// leave source ancestry and perform the transition effect
		push(transition.onTraverse, behavior(sourceAncestors[i]).leave, transition.transitionBehavior);

		// enter the target ancestry
		while (i < targetAncestors.length) {
			this.cascadeElementEntry(transition, behavior, targetAncestors[i++], targetAncestors[i], behavior => push(transition.onTraverse, behavior));
		}

		// trigger cascade
		push(transition.onTraverse, behavior(transition.target!).endEnter);
	}

	cascadeElementEntry(transition: Transition, behavior: (vertexOrRegion: Vertex | Region) => Behavior, vertex: Vertex, next: Vertex, task: (behavior: Array<Action>) => void) {
		task(behavior(vertex).beginEnter);

		if (next && vertex instanceof State) {
			for (const region of vertex.regions) {
				task(behavior(region).beginEnter);

				if (region !== next.parent) {
					task(behavior(region).endEnter);
				}
			}
		}
	}
}

/** Bootstraps all the elements within a state machine model. */
/** @internal */ class InitialiseElements extends Visitor<boolean> {
	/** @internal */ readonly behaviors: { [id: string]: Behavior } = {};

	/** @internal */ behavior(namedElement: Vertex | Region): Behavior {
		return this.behaviors[namedElement.toString()] || (this.behaviors[namedElement.toString()] = new Behavior());
	}

	visitNamedElement(namedElement: Vertex | Region, deepHistoryAbove: boolean) {
		this.behavior(namedElement).leave.push((message, instance) => console.log(`${instance} leave ${namedElement.qualifiedName}`));
		this.behavior(namedElement).beginEnter.push((message, instance) => console.log(`${instance} enter ${namedElement.qualifiedName}`));
	}

	visitRegion(region: Region, deepHistoryAbove: boolean) {
		const regionInitial = region.vertices.reduce<PseudoState | undefined>((result, vertex) => vertex instanceof PseudoState && vertex.isInitial() ? vertex : result, undefined);

		// cascade to child vertices
		for (const vertex of region.vertices) {
			vertex.accept(this, deepHistoryAbove || (regionInitial && regionInitial.kind === PseudoStateKind.DeepHistory));
		}

		// leave the curent active child state when exiting the region
		this.behavior(region).leave.push((message, instance) => {
			const currentState = instance.getCurrent(region); // NOTE: fix for Joel bug

			if (currentState) {
				invoke(this.behavior(currentState).leave, message, instance);
			}
		});

		// enter the appropriate child vertex when entering the region
		if (deepHistoryAbove || !regionInitial || regionInitial.isHistory()) { // NOTE: history needs to be determined at runtime
			this.behavior(region).endEnter.push((message, instance, deepHistory) => invoke((this.behavior((deepHistory || regionInitial!.isHistory()) ? instance.getLastKnownState(region) || regionInitial! : regionInitial!)).enter(), message, instance, deepHistory || regionInitial!.kind === PseudoStateKind.DeepHistory));
		} else {
			// TODO: validate initial region
			push(this.behavior(region).endEnter, this.behavior(regionInitial).enter());
		}

		this.visitNamedElement(region, deepHistoryAbove);
	}

	visitVertex(vertex: Vertex, deepHistoryAbove: boolean) {
		super.visitVertex(vertex, deepHistoryAbove);

		// update the parent regions current state
		this.behavior(vertex).beginEnter.push((message, instance) => {
			if (vertex.parent) {
				instance.setCurrent(vertex.parent, vertex);
			}
		});
	}

	visitPseudoState(pseudoState: PseudoState, deepHistoryAbove: boolean) {
		super.visitPseudoState(pseudoState, deepHistoryAbove);

		// evaluate comppletion transitions once vertex entry is complete
		if (pseudoState.isInitial()) {
			this.behavior(pseudoState).endEnter.push((message, instance, deepHistory) => {
				let currentState: State | undefined;

				if ((deepHistory || pseudoState.isHistory()) && (currentState = instance.getLastKnownState(pseudoState.parent))) {
					invoke(this.behavior(pseudoState).leave, message, instance);
					invoke(this.behavior(currentState).enter(), message, instance, deepHistory || pseudoState.kind === PseudoStateKind.DeepHistory);
				} else {
					traverse(pseudoState.outgoing[0], instance);
				}
			});
		} else if (pseudoState.kind === PseudoStateKind.Terminate) {
			// terminate the state machine instance upon transition to a terminate pseudo state
			this.behavior(pseudoState).beginEnter.push((message, instance) => instance.isTerminated = true);
		}
	}

	visitState(state: State, deepHistoryAbove: boolean) {
		// NOTE: manually iterate over the child regions to control the sequence of behavior
		for (const region of state.regions) {
			region.accept(this, deepHistoryAbove);

			push(this.behavior(state).leave, this.behavior(region).leave);
			push(this.behavior(state).endEnter, this.behavior(region).enter());
		}

		this.visitVertex(state, deepHistoryAbove);

		// add the user defined behavior when entering and exiting states
		push(this.behavior(state).leave, state.exitBehavior);
		push(this.behavior(state).beginEnter, state.entryBehavior);
	}

	visitStateMachine(stateMachine: StateMachine, deepHistoryAbove: boolean) {
		super.visitStateMachine(stateMachine, deepHistoryAbove);

		// initiaise all the transitions once all the elements have been initialised
		stateMachine.accept(new InitialiseTransitions(), (vertexOrRegion: Vertex | Region): Behavior => this.behavior(vertexOrRegion));

		// define the behavior for initialising a state machine instance
		stateMachine.onInitialise = this.behavior(stateMachine).enter();
	}
}

/** The object used for log, warning and error messages. */
export let console = {
	log(message?: any, ...optionalParams: any[]): void { },
	warn(message?: any, ...optionalParams: any[]): void { },
	error(message?: any, ...optionalParams: any[]): void { throw message; }
};

/**
 * Replace the default console object to implement custom logging.
 * @param newConsole An object to send log, warning and error messages to.
 */
export function setConsole(newConsole: {
	log(message?: any, ...optionalParams: any[]): void;
	warn(message?: any, ...optionalParams: any[]): void;
	error(message?: any, ...optionalParams: any[]): void;
}): void {
	console = newConsole;
}

/** Flag to make internal [[Transition]]s trigger completion events for [[State]] they are in. */
export var internalTransitionsTriggerCompletion: boolean = false;

/**
 * Change the bahaviour of internal [[Transition]]s in respect to trigering completion events for the [[State] they are in.
 * @param value True for internal [[Transition]]s in respect to trigering completion events for the [[State] they are in.
 */
export function setInternalTransitionsTriggerCompletion(value: boolean): void {
	internalTransitionsTriggerCompletion = value;
}

/**
 * Validates a [[StateMachine]] model for correctness (see the constraints defined within the UML Superstructure specification).
 * 
 * Validation warnings and errors are sent to the console.warn and console.error callbacks.
 * @param model The [[StateMachine]] model to validate.
 */
export function validate(model: StateMachine): void {
	model.accept(new Validator());
}

/** Class used to validate a [[StateMachine]] model for semantic integrity. */
/** @internal */ class Validator extends Visitor<string> {
	/** Validates a [[PseudoState]]. */
	public visitPseudoState(pseudoState: PseudoState): void {
		super.visitPseudoState(pseudoState);

		if (pseudoState.kind === PseudoStateKind.Choice || pseudoState.kind === PseudoStateKind.Junction) {
			// [7] In a complete statemachine, a junction vertex must have at least one incoming and one outgoing transition.
			// [8] In a complete statemachine, a choice vertex must have at least one incoming and one outgoing transition.
			if (pseudoState.outgoing.length === 0) {
				console.error(`${pseudoState}: ${pseudoState.kind} pseudo states must have at least one outgoing transition.`);
			}

			// choice and junction pseudo state can have at most one else transition
			if (pseudoState.outgoing.filter((transition: Transition) => { return transition.guard === FalseFunc; }).length > 1) {
				console.error(`${pseudoState}: ${pseudoState.kind} pseudo states cannot have more than one Else transitions.`);
			}
		} else {
			// non choice/junction pseudo state may not have else transitions
			if (pseudoState.outgoing.filter((transition: Transition) => { return transition.guard === FalseFunc; }).length !== 0) {
				console.error(`${pseudoState}: ${pseudoState.kind} pseudo states cannot have Else transitions.`);
			}

			if (pseudoState.isInitial()) {
				if (pseudoState.outgoing.length > 1) {
					// [1] An initial vertex can have at most one outgoing transition.
					// [2] History vertices can have at most one outgoing transition.
					console.error(`${pseudoState}: initial pseudo states must have no more than one outgoing transition.`);
				} else if (pseudoState.outgoing.length === 1) {
					// [9] The outgoing transition from an initial vertex may have a behavior, but not a trigger or guard.
					if (pseudoState.outgoing[0].guard !== TrueFunc) {
						console.error(`${pseudoState}: initial pseudo states cannot have a guard condition.`);
					}
				}
			}
		}
	}

	/** Validates a [[Region]]. */
	public visitRegion(region: Region): void {
		super.visitRegion(region);

		// [1] A region can have at most one initial vertex.
		// [2] A region can have at most one deep history vertex.
		// [3] A region can have at most one shallow history vertex.
		let initial = 0, deepHistory = 0, shallowHistory = 0;

		for (const vertex of region.vertices) {
			if (vertex instanceof PseudoState) {
				if (vertex.kind === PseudoStateKind.Initial) {
					initial++;
				} else if (vertex.kind === PseudoStateKind.DeepHistory) {
					deepHistory++;
				} else if (vertex.kind === PseudoStateKind.ShallowHistory) {
					shallowHistory++;
				}
			}
		}

		if (initial > 1) {
			console.error(`${region}: regions may have at most one initial pseudo state.`);
		}

		if (deepHistory > 1) {
			console.error(`${region}: regions may have at most one deep history pseudo state.`);
		}

		if (shallowHistory > 1) {
			console.error(`${region}: regions may have at most one shallow history pseudo state.`);
		}
	}
	public visitState(state: State): void {
		super.visitState(state);

		if (state.regions.filter(region => region.name === Region.defaultName).length > 1) {
			console.error(`${state}: a state cannot have more than one region named ${Region.defaultName}`);
		}
	}

	/** Validates a [[FinalState]]. */
	public visitFinalState(finalState: FinalState): void {
		super.visitFinalState(finalState);

		// [1] A final state cannot have any outgoing transitions.
		if (finalState.outgoing.length !== 0) {
			console.error(`${finalState}: final states must not have outgoing transitions.`);
		}

		// [2] A final state cannot have regions.
		if (finalState.regions.length !== 0) {
			console.error(`${finalState}: final states must not have child regions.`);
		}

		// [4] A final state has no entry behavior.
		if (finalState.entryBehavior.length > 0) {
			console.warn(`${finalState}: final states may not have entry behavior.`);
		}

		// [5] A final state has no exit behavior.
		if (finalState.exitBehavior.length > 0) {
			console.warn(`${finalState}: final states may not have exit behavior.`);
		}
	}

	/** Validates a [[Transition]]. */
	public visitTransition(transition: Transition): void {
		super.visitTransition(transition);

		// Local transition target vertices must be a child of the source vertex
		if (transition.kind === TransitionKind.Local) {
			if (transition.target && transition.target.ancestry().indexOf(transition.source) === -1) {
				console.error(`${transition}: local transition target vertices must be a child of the source composite sate.`);
			}
		}
	}
}